https://www.zhihu.com/question/29637351

socket 与 TCP/IP 之间是唇齿相依般的关系，联系紧密，先来看下维基百科对 socket 的定义。socket 是计算机网络中用于在节点内发送或接收数据的内部端点。
具体来说，它是网络软件 (协议栈) 中这个端点的一种表示，包含通信协议、目标地址、状态等，是系统资源的一种形式。它在网络中所处的位置大致就是下面的黑色部分，应用层与传输层之间。
其中的传输层就是 TCP/IP 所在的地方，而你平时通过代码编写的应用程序大多属于应用层范畴，socket 在这里起到就是连接应用层与传输层的作用。
socket 的诞生是为了应用程序能够更方便的将数据经由传输层来传输，所以它本质上就是对 TCP/IP 的运用进行了一层封装，然后应用程序直接调用 socket API 即可进行通信。那么它是如何工作的呢？
它分为 2 个部分，服务端需要建立 socket 来监听指定的地址，然后等待客户端来连接。而客户端则需要建立 socket 并与服务端的 socket 地址进行连接。

值得注意的是，传输的过程涉及到数据 Copy，不过这些 Copy 是必不可少的。其中的发送缓冲区和接收缓冲区就是套接字缓存 (socket buffer)。
连接使用完之后需要关闭，不过 TCP/IP 连接关闭过程比创建更复杂一些，次数多了一次，这就是经典的“四次握手”过程。
简单总结一下 socket。socket 是进程间数据传输的媒介，为了保证连接的可靠，你需要特别注意建立连接和关闭连接的过程。
为了确保准确、完整的数据传输，客户端和服务端来回进行了多次网络通信才得以完成连接的创建和关闭，这同时也是你在运用一个连接时所花费的额外成本。

链接：https://www.zhihu.com/question/29637351/answer/534704474


---关于socket阻塞与非阻塞情况下的recv、send、read、write返回值
#https://www.huaweicloud.com/articles/0906e8442277b117733fa2d95b26b158.html
【摘要】1、阻塞模式与非阻塞模式下recv的返回值各代表什么意思？有没有区别？（就我目前了解阻塞与非阻塞recv返回值没有区分，都是 <0：出错，=0：连接关闭，>0接收到数据大小，特别：返回值 <0时并且(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况下认为连接是正常的，继续接收。只是阻塞模式下recv会阻塞着接收数据，非...
1、阻塞模式与非阻塞模式下recv的返回值各代表什么意思？有没有区别？（就我目前了解阻塞与非阻塞recv返回值没有区分，都是 <0：出错，=0：连接关闭，>0接收到数据大小，特别：返回值 <0时并且(errno == eintr || errno == ewouldblock || errno == eagain)的情况下认为连接是正常的，继续接收。只是阻塞模式下recv会阻塞着接收数据，非阻塞模式下如果没有数据会返回，不会阻塞着读，因此需要 循环读取< span>

2、阻塞模式与非阻塞模式下write的返回值各代表什么意思？有没有区别？

阻塞与非阻塞write返回值没有区分，都是 <0：出错，=0：连接关闭，>0发送数据大小，特别：返回值 <0时并且(errno == eintr || errno == ewouldblock || errno == eagain)的情况下认为连接是正常的，继续发送。只是阻塞模式下write会阻塞着发送数据，非阻塞模式下如果暂时无法发送数据会返回，不会阻塞着 write，因此需要循环发送< span>

3、阻塞模式下read返回值 < 0 && errno != eintr && errno != ewouldblock && errno != eagain时，连接异常，需要关闭，read返回值 < 0 && (errno == eintr || errno == ewouldblock || errno == eagain)时表示没有数据，需要继续接收，如果返回值大于0表示接送到数据。 < span>

非阻塞模式下read返回值 < 0表示没有数据，= 0表示连接断开，> 0表示接收到数据。 

这2种模式下的返回值是不是这么理解，有没有跟详细的理解或跟准确的说明？ 

4、阻塞模式与非阻塞模式下是否send返回值 < 0 && (errno == eintr || errno == ewouldblock || errno == eagain)表示暂时发送失败，需要重试，如果send返回值 <= 0, && errno != eintr && errno != ewouldblock && errno != eagain时，连接异常，需要关闭，如果send返回值 > 0则表示发送了数据？send的返回值是否这么理解，阻塞模式与非阻塞模式下send返回值=0是否都是发送失败，还是那个模式下表示暂时不可发送，需要 重发？

转载于:https://blog.51cto.com/laokaddk/1054135

----Socket简介
Socket简介Socket是进程通讯的一种方式，即调用这个网络库的一些API函数实现分布在不同主机的相关进程之间的数据交换。
几个定义：（1）IP地址：即依照TCP/IP协议分配给本地主机的网络地址，两个进程要通讯，任一进程首先要知道通讯对方的位置，即对方的IP。
（2）端口号(port)：用来辨别本地通讯进程，一个本地的进程在通讯时均会占用一个端口号，不同的进程端口号不同，因此在通讯前必须要分配一个没有被访问的端口号。
（3）连接：指两个进程间的通讯链路。
（4）半相关：网络中用一个三元组可以在全局唯一标志一个进程：（协议，本地地址，本地端口号）这样一个三元组，叫做一个半相关,它指定连接的每半部分。
（4）全相关：一个完整的网间进程通信需要由两个进程组成，并且只能使用同一种高层协议。也就是说，不可能通信的一端用TCP协议，而另一端用UDP协议。
因此一个完整的网间通信需要一个五元组来标识：（协议，本地地址，本地端口号，远地地址，远地端口号）这样一个五元组，叫做一个相关（association），即两个协议相同的半相关才能组合成一个合适的相关，或完全指定组成一连接。

二、客户/服务器模式在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户/服务器（Client/Server, C/S）模式，即客户向服务器发出服务请求，服务器接收到请求后，提供相应的服务。
客户/服务器模式的建立基于以下两点：
（1）首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用。
（2）其次，网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区，因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务器模式的TCP/IP。
服务器端：其过程是首先服务器方要先启动，并根据请求提供相应服务：
（1）打开一通信通道并告知本地主机，它愿意在某一公认地址上的某端口（如FTP的端口可能为21）接收客户请求；
（2）等待客户请求到达该端口；
（3）接收到客户端的服务请求时，处理该请求并发送应答信号。
接收到并发服务请求，要激活一新进程来处理这个客户请求（如UNIX系统中用fork、exec）。
新进程处理此客户请求，并不需要对其它请求作出应答。服务完成后，关闭此新进程与客户的通信链路，并终止。
（4）返回第（2）步，等待另一客户请求。
（5）关闭服务器客户端：（1）打开一通信通道，并连接到服务器所在主机的特定端口；（2）向服务器发服务请求报文，等待并接收应答；继续提出请求......（3）请求结束后关闭通信通道并终止。
从上面所描述过程可知：（1）客户与服务器进程的作用是非对称的，因此代码不同。（2）服务器进程一般是先启动的。只要系统运行，该服务进程一直存在，直到正常或强迫终止。Socket编程所牵涉的东西非常宽泛，调用各种编程语言对socket的TCP（TCP可靠通信的实现方式）和UDP封装进行网络通信，可以是监听外部链接，也可以是主动发起链接请求，发送特定协议并进行通信，如何制定协议规范，如何进行协议的编码和解码，如何将协议数据转换为二进制数据发送到网络上和从网络接收辨别且处理成功（牵涉到TCP粘包等问题），如何针对建立的链接进行管理等。。。。
作者：wuxinliulei
链接：https://www.zhihu.com/question/29637351/answer/67610424


Socket难点
数据粘包
心跳维持
数据丢包
性能问题

7层网络模型-
OSI基础层：物理层（Physical）、数据链路层（Datalink）、网络层（Network)
传输层（Transport)：TCP-UDP协议层、
Socket高级层：会话层（Session)、表示层（Presentation）、应用层（Application)

作者：慕课网
链接：https://www.zhihu.com/question/29637351/answer/1945667834

